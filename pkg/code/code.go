// Copyright (C) 2019 rameshvk. All rights reserved.
// Use of this source code is governed by a MIT-style license
// that can be found in the LICENSE file.

// Package code has helpers to generate GO AST nodes
//
// Most functions in this package return a NodeMarshaler which allows
// chaining definitions:
//
//     stmt := code.If(code.Ident("x").Op("<", code.Ident("y"))
//     stmt = stmt.Then(....)
//
//
// The actual ASTs can then be generated by calling `MarshalNode` with
// a scope provided. The scope parameter allows code generation to
// use unique local names as needed.
//
// The NodeMarshalers are the `definition` and the two step
// "definition and then generation" process allows having
// parameterized definitions without inventing a templating language
// for it.
package code

import (
	"fmt"
	"go/ast"
	"go/token"
	"strconv"
	"strings"

	"golang.org/x/tools/go/packages"
)

// Nil is the nil literal
func Nil() NodeMarshaler {
	return Ident("nil")
}

// Rune is a rune literal
func Rune(r rune) NodeMarshaler {
	value := fmt.Sprintf("'%c'", r)
	return nodef(func(*Scope) ast.Node {
		return &ast.BasicLit{Kind: token.CHAR, Value: value}
	})
}

// Literal is a literal value (integer/float/string)
func Literal(v interface{}) NodeMarshaler {
	var tok token.Token
	value := fmt.Sprint(v)
	switch v.(type) {
	case int, uint, int32, uint32, int64, uint64, byte:
		tok = token.INT
	case float32, float64:
		tok = token.FLOAT
	case complex64, complex128:
		tok = token.IMAG
	case string:
		tok = token.STRING
	}
	return nodef(func(*Scope) ast.Node {
		return &ast.BasicLit{Kind: tok, Value: value}
	})
}

// Ident is a specific identifier
func Ident(s string) NodeMarshaler {
	return nodef(func(*Scope) ast.Node {
		return ast.NewIdent(s)
	})
}

// IdentPrefix is an unique local identifier using the provided prefix
// which should not be empty
func IdentPrefix(prefix string) NodeMarshaler {
	var name string
	return nodef(func(s *Scope) ast.Node {
		if name == "" {
			name = s.PickName(prefix)
			s.Vars[name] = ast.NewIdent(name)
			return s.Vars[name]
		}
		return ast.NewIdent(name)
	})

}

// If represents an if statement.  For the variant with assignment,
// use the If2 function.
func If(cond NodeMarshaler) NodeMarshaler {
	return nodef(func(s *Scope) ast.Node {
		return &ast.IfStmt{Cond: cond.MarshalNode(s).(ast.Expr)}
	})
}

// If2 represents an if statment with an assignment and a condition.
func If2(let, cond NodeMarshaler) NodeMarshaler {
	return nodef(func(s *Scope) ast.Node {
		var init ast.Stmt
		n := let.MarshalNode(s)
		if nx, ok := n.(ast.Stmt); ok {
			init = nx
		} else {
			init = &ast.ExprStmt{X: n.(ast.Expr)}
		}
		return &ast.IfStmt{
			Init: init,
			Cond: cond.MarshalNode(s).(ast.Expr),
		}
	})
}

// Assign represents an assigment statement.
//
// Op can be "+=" or ":=" etc.
func Assign(op string, kvpairs ...NodeMarshaler) NodeMarshaler {
	var tok token.Token
	for kk := token.ILLEGAL; kk <= token.VAR; kk++ {
		if kk.String() == op {
			tok = kk
		}
	}
	return nodef(func(s *Scope) ast.Node {
		result := &ast.AssignStmt{Tok: tok}
		for k := 0; k < len(kvpairs); k += 2 {
			// TODO: update scope.Vars
			l, r := kvpairs[k].MarshalNode(s), kvpairs[1+k].MarshalNode(s)
			result.Lhs = append(result.Lhs, l.(ast.Expr))
			result.Rhs = append(result.Rhs, r.(ast.Expr))
		}
		return result
	})

}

// File creates a new ast.File with the provided contents
func File(pkgName string, contents ...NodeMarshaler) NodeMarshaler {
	return nodef(func(s *Scope) ast.Node {
		f := &ast.File{Name: ast.NewIdent(pkgName)}
		s.Stash[fileKey] = f
		// first decl is an empty import
		imports := &ast.GenDecl{Tok: token.IMPORT}
		f.Decls = append(f.Decls, imports)
		for _, content := range contents {
			n := content.MarshalNode(s)
			switch n := n.(type) {
			case nil:
			case ast.Decl:
				f.Decls = append(f.Decls, n)
			case *ast.ImportSpec:
				f.Imports = append(f.Imports, n)
			default:
				panic("unexpected file content type")
			}
		}
		if len(imports.Specs) == 0 {
			f.Decls = f.Decls[1:]
		}
		return f
	})
}

// Import imports a package if needed. If the package already exists,
// it uses the same name as it used to have
func Import(pkg string) NodeMarshaler {
	return nodef(func(s *Scope) ast.Node {
		path := `"` + pkg + `"`
		f := s.Stash[fileKey].(*ast.File)
		for _, spec := range f.Imports {
			if spec.Path.Value == path {
				return ast.NewIdent(spec.Name.Name)
			}
		}
		cfg := &packages.Config{Mode: packages.NeedName}
		pkgs, err := packages.Load(cfg, pkg)
		name := ""
		if err == nil && len(pkgs) == 1 && pkgs[0].Name != "" {
			name = pkgs[0].Name
		} else {
			parts := strings.Split(pkg, "/")
			name = parts[len(parts)-1]
		}
		idx := 0
		uniq := name
		for !isUniqueImport(f, uniq) {
			idx++
			uniq = name + strconv.Itoa(idx)
		}

		spec := &ast.ImportSpec{
			Name: ast.NewIdent(uniq),
			Path: &ast.BasicLit{Kind: token.STRING, Value: path},
		}
		f.Imports = append(f.Imports, spec)
		imports := f.Decls[0].(*ast.GenDecl)
		if uniq == name {
			spec = &ast.ImportSpec{Path: spec.Path}
		}
		imports.Specs = append(imports.Specs, spec)
		return ast.NewIdent(uniq)
	})
}

func isUniqueImport(f *ast.File, name string) bool {
	for _, spec := range f.Imports {
		if spec.Name.Name == name {
			return false
		}
	}
	return true
}

// AddDecl adds a declaration to the current file
func AddDecl(s *Scope, n NodeMarshaler) {
	f := s.Stash[fileKey].(*ast.File)
	f.Decls = append(f.Decls, n.MarshalNode(s).(ast.Decl))
}

// Func creates a func decl.
func Func(name string) NodeMarshaler {
	return nodef(func(s *Scope) ast.Node {
		return &ast.FuncDecl{
			Name: ast.NewIdent(name),
			Recv: &ast.FieldList{},
			Type: &ast.FuncType{
				Params:  &ast.FieldList{},
				Results: &ast.FieldList{},
			},
		}
	})
}

// Return returns the set of expressions
func Return(args ...NodeMarshaler) NodeMarshaler {
	return nodef(func(s *Scope) ast.Node {
		stmt := &ast.ReturnStmt{}
		for _, arg := range args {
			x := arg.MarshalNode(s).(ast.Expr)
			stmt.Results = append(stmt.Results, x)
		}
		return stmt
	})
}

var fileKey = &struct{}{}
